\documentclass[runningheads]{llncs}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage[Latin,Greek]{ucharclasses}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{newunicodechar}
\usepackage{proof}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}
\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{adjustbox}

\subtitle{Everybody's Got To Be Somewhere$^{\text{\cite{codebruijn}}}$}
\title{\includegraphics[width=0.4\textwidth]{seal.png}~\\[1cm] From Debruijn to co-Debruijn using Category Theory}
\subtitle{Everybody's Got To Be Somewhere$^{\text{\cite{codebruijn}}}$}
\titlerunning{Elaboration on co-Debruijn}
\institute{Chair of Programming Languages, University of Freiburg \\
  \email{weidner@cs.uni-freiburg.de}}
\author{Marius Weidner}

\begin{document}

\let\oldaddcontentsline\addcontentsline{}
\def\addcontentsline#1#2#3{}
\maketitle
\def\addcontentsline#1#2#3{\oldaddcontentsline{#1}{#2}{#3}}

\makeatletter
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
                       {-8\p@ \@plus -4\p@ \@minus -4\p@}% Formerly -18\p@ \@plus -4\p@ \@minus -4\p@
                       {-0.5em \@plus -0.22em \@minus -0.1em}%
                       {\normalfont\normalsize\bfseries\boldmath}}
\makeatother

\begin{abstract}
  We explore the connection between De Bruijn indices used for variable representation in an intrinsically scoped syntax and the usage of co-De Bruijn representation. 
  To understand the duality between De Bruijn and co-De Bruijn, we will look into the categorical concepts underpinning scopes, binders, and intrinsically scoped syntaxes in general. 
  All definitions, examples, and concepts presented here are directly derived from Conor McBride's paper$^{\text{\cite{codebruijn}}}$, with certain modifications and additional definitions and examples included. 
  The original paper is written in Agda code but should have the same meaning as the on-paper math presented here. 
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents

\section{Scopes and Binders Categorically}
Before we begin, it is important to fully understand the concept of variables, scopes, and binders. These concepts form the foundation of our exploration.
Subsequently, we will examine these concepts within the framework of category theory. 
Every categorical concept used will be defined and explained, thus any prerequisite knowledge beyond a solid understanding of set theory is not required.

\subsubsection{Variables}
serve as placeholders for terms in a language and are bound by binding terms within a language. 
While variables could also appear free, i.e., not bound, we do not look at languages that allow this. 
In fact, our very goal is to ensure that terms in some language can only be constructed in such a way that variables are used only when they are bound.

\subsubsection{Scopes} fundamentally hold information about all the variables present within a particular term. 
This information might simply entail the quantity of available variables or it could extend to include additional informationm such as the type of a variable. 

\subsubsection{Binding} terms introduce new variables within a subterm, thereby expanding the scope of the subterm by one or more variables.

\subsection{The Category of Scopes}
\begin{definition}
  A category consists of a set of objects and a set of morphisms. 
  Morphisms are indexed by two objects: source and target. 
  Given a Category $ğ’$, we denote its objects as $|ğ’|$, and its morphisms from specified source to target as $ğ’(S, T)$, where $S, T âˆˆ |ğ’|$.
\end{definition}

Interestingly, this definition of a category differs from other definitions in the sense that morphisms are only defined between concrete objects $T$ and $S$. 
Morphisms do not exist independently of their source and target objects. 
This perspective is somewhat a constructivist view on categories, which fits, considering the original paper is formalized in Agda.

\begin{definition}
  For every set $X$, we define the category of scopes as $Î”_+^X$ with objects \(\bar{x}, \bar{y}, \bar{s} âˆˆ X^*\) and morphisms $f, g âˆˆ Î”_+^X(\bar{x}, \bar{y})$ inductively defined by the following inference rules in infix notation\footnote{In the construction of morphisms using inference rules, we usually omit the axiom rule $Â·$.}:
  \[
        \infer[Â·]{
          Îµ âŠ‘ Îµ
        }{}
        \quad
        \infer[1]{
          \bar{x}x âŠ‘ \bar{y}x
        }{
          \bar{x} âŠ‘ \bar{y}
        }
        \quad
        \infer[0]{
          \bar{x} âŠ‘ \bar{y}y
        }{
          \bar{x} âŠ‘ \ \bar{y}
        }
  \]
\end{definition}

In the category of scopes, objects are represented are scopes, while morphisms are \emph{order-preserving embeddings}. 
A scope is represented as a list of \emph{sorts}, indicating the sort of variables present in the scope, with the length of the list indicating the number of variables in the scope.

\begin{example}
  Consider constructing the language of second-order lambda calculus, where both expression and type variables exist. 
  In such a scenario, we can represent the set of sorts as $X = \{e, t\}$, where $e$ represents expression variables and $t$ represents type variables.
\end{example}  

A morphism in $Î”_+^X$ exists only if we can embed one scope into another by adding variables into the source scope without altering the order of variables from the source scope. 
Once more, morphisms are defined inductively, which aligns with a constructive approach.

\begin{example}
  Let $X = âŠ¤$, where $âŠ¤$ is the set with a single element $â‹†$. In the category $Î”_+^T$, objects correspond to \emph{numbers} $n, p, q âˆˆ âŠ¤^* = â„•$. 
  In this scenario, objects are scopes with $n$ variables, all of the same \emph{sort} $â‹†$. 
  Morphisms map from a smaller scope $p$ to a larger scope $q$ by selecting $p$ variables in $q$ and mapping all variables from $p$ to them.
  Figure \ref{fig:ex1} illustrates the embedding of a scope with $3$ variables into one with $5$ variables in the required order-preserving manner.
  \begin{figure}[]
    \centering
    \adjustbox{scale=0.75}{
      \begin{tikzcd}
        3 \arrow[rr, "10101"]  &         & 5 &   &   &   &   &   &   \\
                               &         &   &   &   &   &   &   &   \\
        â€¢ \arrow[rr, no head]  &         & â€¢ &   &   &   &   &   & 1 \\
                               &         & âˆ˜ &   &   &   &   & 0 &   \\
        â€¢ \arrow[rr, no head]  &         & â€¢ &   &   &   & 1 &   &   \\
                               &         & âˆ˜ &   &   & 0 &   &   &   \\
        â€¢ \arrow[rr, no head]  &         & â€¢ &   & 1 &   &   &   &   \\
                               &         &   & Â· &   &   &   &   &  
      \end{tikzcd}
    }
    \caption{Embedding a scope with $3$ variables into a scope with $5$}
    \label{fig:ex1}
  \end{figure}
\end{example}

\begin{remark}
  Morphisms in $Î”_+^X$ can be represented by \emph{bit vectors} $\bar{b} âˆˆ \{0, 1\}^*$ with one bit per variable of the target scope telling whether it has been mapped to or skipped by the source scope.
\end{remark}
\begin{definition}
  We define the infix operation of composition $f;g$ for two morphisms $f âˆˆ Î”_+^X(\bar{x}, \bar{y})$ and $g âˆˆ Î”_+^X(\bar{y}, \bar{z})$, resulting in a morphism $h âˆˆ Î”_+^X(\bar{x}, \bar{z})$, inductively on the inference rules of morphisms:

  \quad $Â·  \ \ \, \, ; \ Â· \ \ \ = \ Â·$

  \quad $f 1  \ ; \ g 1 \ = \ (f;g)1$

  \quad $f 0 \ ; \ g 1  \ = \ (f;g)0$

  \quad $f \ \ \, ; \ g 0 \ = \ (f;g)0$
\end{definition}
\begin{remark}
  The operation $f;g$ reads `$f$ than $g$' and applies $f$ first and the result to $g$, in contrast to $f âˆ˜ g$ which reads `$f$ after $g$'. 
  The operation $f;g$ reads `$f$ than $g$' and executes the morphism $f$ first, and then applies $g$ to the result. 
  This contrasts with the composition $f âˆ˜ g$, which reads `$f$ after $g$', indicating the application of $g$ followed by $f$.
\end{remark}
\begin{example}
  Let's reconsider the category $Î”_+^âŠ¤$. Objects are represented by numbers, and morphisms can be encoded as bit vectors.
  \begin{figure}[h]
    \centering
    \adjustbox{scale=0.75}{
          \begin{tikzcd}
            2 \arrow[rr, "101"]  &  & 3 &  & 3 \arrow[rr, "10101"]&  & 5 &  & 2 \arrow[rr, "10001"]   &  & 5 \\
                                  &  &   &  &                       &  &   &  &                       &  &   \\
            â€¢ \arrow[rr, no head] &  & â€¢ &  & â€¢ \arrow[rr, no head] &  & â€¢ &  & â€¢ \arrow[rr, no head] &  & â€¢ \\
                                  &  &   &  &                       &  & âˆ˜ &  &                       &  & âˆ˜ \\
                                  &  & âˆ˜ & ; & â€¢ \arrow[rr, no head] &  & â€¢ & =  &                       &  & âˆ˜ \\
                                  &  &   &  &                       &  & âˆ˜ &  &                       &  & âˆ˜ \\
            â€¢ \arrow[rr, no head] &  & â€¢ &  & â€¢ \arrow[rr, no head] &  & â€¢ &  & â€¢ \arrow[rr, no head] &  & â€¢
          \end{tikzcd}
    }
    \caption{Composition of two embeddings in the category $Î”_+^âŠ¤$}
    \label{fig:ex2}
  \end{figure}
\end{example}
\begin{corollary}
  Composition of morphisms in $Î”_+^X$ is associative, i.e., $f; (g; h) = (f; g); h$ for $f âˆˆ Î”_+^X(\bar{x}, \bar{y})$, $g âˆˆ Î”_+^X(\bar{y}, \bar{z})$, and $h âˆˆ Î”_+^X(\bar{x}, \bar{s})$. 
  The proof follows straightforward induction.
\end{corollary}
\begin{corollary}
  For every object $\bar{x}$ in the category $Î”_+^X$, there exists an identity morphism $id_{\bar{x}} : \bar{x} âŠ‘ \bar{x}$. The identity morphism can be constructed for every $\bar{x}$ using the axiom inference rule followed by $â€–\bar{x}â€–$ times applying the 1 rule. 
  Additionally, the equalities $id_{\bar{x}} ; f = f$ and $g ; id_{\bar{x}} = g$ hold for all $\bar{x}$ and morphisms $f âˆˆ Î”_+^X(\bar{x}, \bar{y})$ and $g âˆˆ Î”_+^X(\bar{y}, \bar{x})$, respectively. 
  This can straightforwardly be proven through induction.
\end{corollary}
\begin{proposition}
  The category of scopes $Î”_+^X$ is a well-defined category for every set $X$. 
  The composition operation $f;g$ is associative. 
  Identity morphisms exist within $Î”_+^X$ and act neutral in composition.
\end{proposition}

This concludes the definition of the category of scopes $Î”_+^X$. 
Primarily, scopes serve as objects in this category and hold information regarding the sorts and quantities of variables present. 
Furthermore, morphisms in this category embed one scope into another in an order-preserving manner. 
Importantly, $Î”_+^X$ is in fact a valid category, characterized by associative morphism composition and the existence of identity morphisms.

\subsection{Intrinsically Scoped De Bruijn Syntax}

Next, we look at the definition of a \emph{intrinsically scoped} language that restricts the construction of terms such that variables can only be used if they were bound previously. 
The indices of the set of terms in this language are objects in the category of scopes and pointing to a variable is achieved by using morphisms.

\begin{definition}
  The indexed set of intrinsically scoped lambda calculus terms $Tm : â„• â†’ Set$, where the index corresponds to the number of variables $n âˆˆ |Î”_+^âŠ¤| = â„•$ in scope inside the term, is defined inductively by the following inference rules\footnote{When constructing the $\$$ rule, we usually omit the dollar sign and, instead, express it by using a space between the two subterms.}:
  \[  
    \infer[\#]{
      Tm \ n
    }{
      1 âŠ‘ n
    }
    \quad
    \infer[\$]{
      Tm \ n
    }{
      Tm \ n &  
      Tm \ n
    }
    \quad
    \infer[Î»]{
      Tm \ n
    }{
      Tm \ (n + 1)
    }
  \]
  \label{def:tm}
\end{definition}

The $Î»$ rule binds a new variable in its body, incrementing $n$ by one within that body. 

In contrast, the variable rule $\#$ points to a variable using a morphism in the scope category, precisely selecting one of the $n$ bound variables. 
The referencing of a variable can be represented by a bit vector of length $n$ with precisely a single $1$ inside it. 
This is in turn equal to a number $m âˆˆ [0, n]$, indicating the position of the sole $1$ in the bit vector.
Numbers used as variables, indicating the amount of binders between the binding and the usage of a variable, are referred to as De Bruijn indices.

\begin{example}
  Consider the $ğ•‚$ and $ğ•Š$ combinators expressed in lambda calculus, comparing their representations with variables as names and intrinsic De Bruijn notation:

  \quad $ğ•‚ = Î»x. Î»y. x \quad \quad \quad \quad \ \ = Î»  Î» \#1$

  \quad $ğ•Š = Î»x. Î»y. Î»z. x \ z \ (y \ z) = Î» Î» Î» \#2 \ \#0 \ (\#1 \ \#0)$

  \noindent Note that, for example, a De Bruijn term $Î» \ \#1$ could not even be defined using the given inference rules.
\end{example}

\section{From De Bruijn to co-De Bruijn}
In the last section, all terms intrinsically possessed, by construction, knowledge of how many variables are in scope. 
Variable constructors then selected one out of all variables in scope. 
Now, our objective is to transition from De Bruijn representation to its dual, the co-De Bruijn representation.
In the co-De Bruijn representation, instead of selecting the variable at the \emph{latest} point in the syntax tree (i.e., the leaf node in the tree, the variable constructor), we determine the fate of a variable at the \emph{earliest} possible moment.
To understand this transition, we must delve deeper into the category of scopes.

\subsection{The Slice Category of Scopes}
\begin{definition}
  If $ğ’$ is a category and $S, T, O âˆˆ |ğ’|$, the slice category $ğ’/O$ has pairs $(S, f)$ as objects, where $f âˆˆ ğ’(S, O)$. Morphisms in $(ğ’/O)((S, f), (T, g))$ are morphisms $h âˆˆ ğ’(S, T)$ such that $f = h;g$.
\end{definition}

The slice category of a given category has pairs of objects and morphisms as objects, where the morphisms must have the objects in the pair as source and the object we slice through as their target. 
The morphisms that remain in the slice category map between these pairs but are simply a subset of the morphisms in the original category, thus composing as expected. 
We refer to the slice category $Î”_+^Xâˆ–\bar{s}$ as the category of subscopes, with objects $\bar{b} \in |Î”_+^Xâˆ–\bar{s}|$ and morphisms $h \in [Î”_+^Xâˆ–\bar{s}](\bar{b}_1, \bar{b}_2)$. 
Given the scope $\bar{s}$ that we slice through, we now have objects that are pairs consisting of a (sub-)scope $\bar{x}$ of $\bar{s}$ and a mapping from $\bar{x}$ to $\bar{s}$.

\begin{remark}
  Objects in $Î”_+^Xâˆ–\bar{s}$ are \emph{bit vectors} $\bar{b} âˆˆ \{0, 1\}^*$ with one bit per variable of slicing scope $\bar{s}$, telling whether it has been selected by the morphisms from the subscope\footnote{We only need one bit telling wether the variable has been selected and no information about the sort of the variables, because the morphisms that is inside the pair already guarantee sort preservation.}.
\end{remark}
\begin{example}
  The morphism $0111$ in $Î”_+^Tâˆ–5$ from $01110$ to $11110$ (or $(3, 01110)$ to $(4, 11110)$) embeds a scope with 3 variables into one with 4 by inserting an additional variable at the very beginning. 
  Given that we sliced with object $5$, both $01110$ and $11110$ are subscopes of a scope with $5$ variables, and the morphism $0111$ effectively embeds one subscope into the other.
  \begin{figure}[]
    \centering
    \adjustbox{scale=0.65}{
      \begin{tikzcd}
        3 \arrow[rdd, "01110"', dotted] \arrow[rr, "0111"]  &   & 4 \arrow[ldd, "11110", dotted] \\
                                                            &   &                                 \\
                                                            & 5 &                                
      \end{tikzcd}  
    }
    \caption{In the diagram, objects in the slice category $Î”_+^âŠ¤âˆ–5$ are represented by dotted arrows along with their source, while normal arrows are actual morphisms.}
    \label{fig:ex3}
  \end{figure}
\end{example}

\begin{definition}
  Objects $T, S âˆˆ |ğ’|$ in category $ğ’$ possess a coproduct object $T + S$ if there exist morphisms $l âˆˆ ğ’(T, T + S)$ and $r âˆˆ ğ’(S, T + S)$ such that for every pair $f âˆˆ C(T,U)$ and $g âˆˆ ğ’(S,U)$, there exists a unique morphism $h âˆˆ ğ’(T + S,U)$ such that $f = l;h$ and $g = r;h$.
\end{definition}
\begin{example}
  Coproduct in the category $Î”_+^âŠ¤âˆ–5$. ... explain
  \begin{figure}[h]
    \centering
    \adjustbox{scale=1}{
      \begin{tikzcd}
        01100 \arrow[rrrrrd, "0110"] \arrow[rrd, "011"'] &  &                           &  &  &       \\
                                                         &  & 11100 \arrow[rrr, "1110"] &  &  & 11110 \\
        11000 \arrow[rrrrru, "1100"'] \arrow[rru, "110"] &  &                           &  &  &      
        \end{tikzcd}
    }
    \caption{Coproduct in the category $Î”_+^âŠ¤âˆ–5$.}
    \label{fig:ex5}
  \end{figure}
\end{example}
\begin{remark}
  The coproduct $\bar{b}â‚ + \bar{b}â‚‚$ of two subscopes $\bar{b}â‚, \bar{bâ‚‚}$ corresponds to the minimal subscope covering both $\bar{b}â‚$ and $\bar{bâ‚‚}$. 
  The coproduct $\bar{b}â‚ + \bar{b}â‚‚$ can be computed by pointwise disjunction of $\bar{b}â‚$ and $\bar{b}â‚‚$. 
\end{remark}

\subsection{Sets Indexed by Scopes}

\begin{definition}
  We define the category $\overline{Set}$ as the category of sets indexed by scopes $\bar{x} âˆˆ X^*$. The category has objects $T, S âˆˆ |\overline{Set}| = X^* \to Set$, where we often abbreviate $X^* \to Set$ as $\bar{X}$. Morphisms $f âˆˆ \overline{Set}(T, S) = \{\bar{x} âˆˆ X^*\} \to T \ \bar{x} \to S \ \bar{x}$ are functions between sets implicitly indexed over the sets' indices.
\end{definition}
\begin{example}
  The set of intrinsically scoped debruijn terms in Definition \ref{def:tm} is an object of $\overline{Set}$.
\end{example}
\begin{definition}
  Let $\_â‡‘\_ : \bar{X} â†’ \bar{X} = (T, \bar{x}) â†¦ (T(\bar{s}) Ã— \bar{s} âŠ‘ \bar{x})$. We write $t â†‘ h$ for elements of  $T â‡‘ \bar{x}$. 
\end{definition}
\begin{remark}
  The set $Tâ‡‘\bar{x}$ packs an set $T âˆˆ \bar{X}$ indexed by $\bar{x} âˆˆ X^*$ applied to a subscope $\bar{s}$ of $\bar{x}$, together with a selection $\bar{b} âˆˆ |Î”_+^Xâˆ–\bar{x}|$ of the variables of $T$.
\end{remark}
\subsection{The Notion of Relevant Pairs}

\begin{definition}
  Let $Cov : \bar{x} âŠ‘ \bar{s} â†’ \bar{y} âŠ‘ \bar{s} â†’ Set$ be the set of \emph{coverings} indexed by morphisms $\bar{b}â‚$ and $\bar{b}â‚‚$

  \[
    \infer[Â·]{
      Cov \ Â· \ Â·
    }{}
    \quad
    \infer[L]{
      Cov \ \bar{b}â‚1 \ \bar{b}â‚‚
    }{
      Cov \ \bar{b}â‚ \ \bar{b}â‚‚
    }
    \quad
    \infer[R]{
      Cov \ \bar{b}â‚ \ \bar{b}â‚‚1
    }{
      Cov \ \bar{b}â‚ \ \bar{b}â‚‚
    }
    \quad
    \infer[B]{
      Cov \ \bar{b}â‚1 \ \bar{b}â‚‚1
    }{
      Cov \ \bar{b}â‚ \ \bar{b}â‚‚
    }
  \]
     
\end{definition}

\begin{remark}
  Coverings $Cov \ \bar{b}â‚ \ \bar{b}â‚‚$ hold data about the coproduct of $\bar{b}â‚$ and $\bar{b}â‚‚$ as well as information about the original appearance of $\bar{b}â‚$ and $\bar{b}â‚‚$.
\end{remark}

\begin{definition}
  Let the set of relevant pairs be defined as 
  $\_Ã—_R\_ : \bar{X} â†’ \bar{X} â†’ \bar{X}  = (T, S, \bar{x}) â†¦ ((\_ â†‘ \bar{b}â‚ : T â‡‘ \bar{x}) Ã— (\_ â†‘ \bar{b}â‚‚ : S â‡‘ \bar{x}) Ã— Cov \ \bar{b}â‚ \ \bar{b}â‚‚)$ +
  were elements are denoted as $\_,_R\_ : T â‡‘ \bar{x} â†’ S â‡‘ \bar{x} â†’ (T Ã—_R S) â‡‘ \bar{x} = (( tâ‚ â†‘ \bar{b}â‚), (tâ‚‚ â†‘ \bar{b}â‚‚)) â†¦ ((tâ‚ â†‘ \bar{b}â‚') , (tâ‚‚ â†‘ \bar{b}â‚‚'), \bar{b}â‚ âŠ• \bar{b}â‚‚) â†‘ \bar{b}'$ \\ 
  \end{itemize}
\end{definition}

\begin{example}
  Look at the term $Î»x. Î»y. Î»z. z \ y = Î» Î» Î»(\#0 \ \#1)$ in De Bruijn notation. \\
  The variable terms could also be written as
  $z' : Tm â‡‘ 3 = \#0 â†‘ 001$ and $y' : Tm â‡‘ 3 = \#1 â†‘ 011$.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      001 \arrow[rrrrrd, "001"] \arrow[rrd, "01"'] &  &                         &  &  &     \\
                                                   &  & âŸ¨ BR \arrow[rrr, "011"] &  &  & 111 \\
      011 \arrow[rrrrru, "011"'] \arrow[rru, "11"] &  &                         &  &  &    
    \end{tikzcd}
    \caption{Covering in the category $Î”_+^âŠ¤âˆ–3$.}
    \label{fig:ex6}
  \end{figure}
  And the application term could be a \emph{relevant pair} $z' ,_R y' : (Tm Ã—_R Tm) â‡‘ 3 = (\#0 â†‘ 01, \#1 â†‘ 11, BR) â†‘ 011$
\end{example}

\subsection{Intrinsically Scoped co-De Bruijn Syntax}
\begin{definition}
  Let $Tm : â„• â†’ Set$ be inductively defined: \\
  \[
     \infer[\#]{
       Tm \ 1
     }{
       \\
     }
     \quad
     \infer[\$]{
       Tm \ n
     }{
       (Tm Ã—_R Tm) \ n
     }
     \quad
     \infer[Î»]{
       Tm \ n
     }{
       Tm \ (n + 1)
     }
  \]
\end{definition}
\begin{example} 
  We again consider the $ğ•‚$ and $ğ•Š$ combinators. 
  For convenience the cover computed by the relevant pair next to the comma. 

  $ğ•‚ = Î»x. Î»y. x \quad \quad \quad \quad \ \ = \lightning$

  $ğ•Š = Î»x. Î»y. Î»z. x \ z \ (y \ z) = Î» \ Î» \ Î»($

  \quad \quad $(((\# â†‘ 10) ,_{[LR]} (\# â†‘ 01)) â†‘ 101) \ ,_{[LRB]} $

  \quad \quad $(((\# â†‘ 10) ,_{[LR]} (\# â†‘ 01)) â†‘ 011) $

  $)$

  The $ğ•‚$ is not definable with our co-De Bruijn syntax because unused variables are not allowed to exist. 
\end{example}

\nocite{catsandtypes}
\printbibliography{}

\end{document}